<div class="wdghtml" taskKey="com.javarush.task.task31.task3110.big08">
<h3>Archiver (8)</h3>
<p>Чтобы узнать какую команду сейчас хочет выполнить пользователь, добавим метод <mark>Operation</mark><br />
<mark> askOperation()</mark> в класс <strong><span class="text-corporate">Archiver</span></strong>. Этот метод должен вывести в консоль список доступных команд и<br />
попросить выбрать одну из них. Для удобства будем просить ввести номер команды, где номер – это<br />
порядковый номер команды в <span class="text-corporate">enum <strong>Operation</strong></span>. Получить порядковый номер значения в <span class="text-corporate">enum’е</span> можно с помощью метода <mark>ordinal()</mark>.<br />
Теперь все готово чтобы переписать main, используя последние достижения науки и техники, а именно<br />
класс <strong><span class="text-corporate">CommandExecutor</span></strong> и метод <mark>askOperation()</mark>.<br />
1. Добавь публичный статический метод <mark>Operation askOperation() throws IOException в класс Archiver</mark>.<br />
<strong>Он должен:</strong><br />
1.1. Использовать методы класса <span class="text-corporate"><strong>ConsoleHelper</strong></span><br />
1.2. Запрашивать у пользователя номер операции, которую он хочет совершить.</p>
<p><strong>Подсказка:</strong><br />
<em>чтобы вывести номер операции «Создать архив», используй: </em><mark>Operation.CREATE.ordinal()</mark></p>
<p>1.3. Возвращать выбранную операцию.</p>
<p><strong>Пример вывода метода askOperation():</strong><br />
<code>Выберите операцию:<br />
0 - упаковать файлы в архив<br />
1 - добавить файл в архив<br />
2 - удалить файл из архива<br />
3 - распаковать архив<br />
4 - просмотреть содержимое архива<br />
5 – выход</code><br />
2. Перепиши метод <mark>main()</mark>:<br />
2.1. Объяви локальную переменную типа <mark class="user">Operation</mark><br />
2.2. В цикле запрашивай новое значение для переменной <strong>п.2.1.</strong> с помощью метода <mark>askOperation()</mark> и вызывай выполнение операции с помощью <mark>CommandExecutor.execute()</mark><br />
2.3. Обеспечь выход из цикла, если пользователь выбрал операцию <mark>Operation.EXIT</mark><br />
2.4. Оберни вызов <mark>askOperation()</mark> и <mark>execute(operation)</mark> в блок <span class="text-neon"><strong>try-catch</strong></span>. Если произойдет исключение <strong><span class="text-yellow">WrongZipFileException</span></strong> выведи сообщение &#171;<em>Вы не выбрали файл архива или выбрали неверный файл.</em>&#187; с помощью <mark>ConsoleHelper</mark>, при любых других исключениях выводи &#171;<em>Произошла ошибка. Проверьте введенные данные.&#187;</em>.<br />
2.5. Проследи, чтобы программа продолжила свою работу (<em>перешла на новый шаг цикла</em>), после обработки исключений.<br />
3. Запусти программу и проверь, что команда “<em>выход</em>” работает.</p>

<hr>
<h3>Archiver (7)</h3>
<p>Мы много всего сделали и можно немного передохнуть.<br />
Создадим, пакет exception и добавим в него два класса <span class="text-corporate"><strong>PathIsNotFoundException</strong></span> и <strong><span class="text-corporate">WrongZipFileException</span></strong>.<br />
Исключение <strong><span class="text-yellow">PathIsNotFoundException</span></strong> будем кидать, если не сможем найти путь, в который нужно распаковать архив, или путь к файлу, который хотим запаковать, или любой другой путь. Исключение <strong><span class="text-yellow">WrongZipFileException</span></strong> будем кидать, если будет попытка сделать что-нибудь с архивом, который не<br />
существует.</p>
<p>1. Создай пакет <strong><span class="text-red">exception</span></strong><br />
2. Добавь в него класс <strong><span class="text-corporate">PathIsNotFoundException</span></strong> унаследованный от <strong><span class="text-corporate">Exception</span></strong><br />
3. Добавь класс <span class="text-corporate"><strong>WrongZipFileException</strong></span>, также унаследованный от <span class="text-corporate"><strong>Exception</strong></span></p>

<hr>
<h3>Archiver (6)</h3>
<p>Представь, что пользователь сообщает нам с помощью переменной <span class="text-corporate"><strong>Operation</strong></span> <mark class="user">operation</mark>, что он хочет сделать. Тогда мы должны проверить значение этой переменной, создать объект соответствующего класса команды и вызвать у него метод execute(). Чтобы не создавать объект класса нужной команды каждый раз, его нужно где-то хранить. Создадим для этих целей класс <strong><span class="text-corporate">CommandExecutor</span></strong>, пусть у него будет открытым только один публичный статический метод <mark>execute(Operation <strong>operation</strong>)</mark>, который найдет нужную команду и вызовет у нее метод execute.</p>
<p>1. Создай класс <strong><span class="text-corporate">CommandExecutor</span></strong>. Он должен быть в корне задачи, не стоит добавлять его в пакет <strong><span class="text-red">command</span></strong><br />
2. Запрети явный вызов конструктора этого класса<br />
3. Добавь в класс приватное статическое константное хранилище команд <span class="text-red">Map&lt;Operation, Command&gt;</span><br />
<strong><span class="text-red"> allKnownCommandsMap</span></strong><br />
4. Проинициализируй переменную <mark class="user">allKnownCommandsMap</mark> так, чтобы каждому значению из <span class="text-corporate"><strong>Operation</strong></span> соответствовала правильная команда.<br />
5. Реализуй публичный статический метод <mark>execute(Operation <strong>operation</strong>) throws Exception</mark>, который должен брать нужную команду из <span class="text-red">allKnownCommandsMap</span> и вызывать у нее метод <mark>execute</mark>.<br />
Догадался ты или нет, но ты только что реализовал паттерн Команда!</p>

<hr>
<h3>Archiver (5)</h3>
<p><strong> Разделим команды на два типа</strong>: те, которые работают непосредственно с архивом и вспомогательные<br />
(например <mark class="green">EXIT</mark>). Все команды первого типа, будут иметь общий функционал, его удобно вынести в какой-то их общий базовый класс. Назовем этот класс <span class="text-corporate"><strong>ZipCommand</strong></span>. Он, как и все классы команд, должен реализовывать интерфейс <strong><span class="text-yellow">Command</span></strong>. Все команды, которые работают с архивом, должны быть унаследованы от класса <span class="text-corporate"><strong>ZipCommand</strong></span>. Мы не будем создавать объекты класса <span class="text-corporate"><strong>ZipCommand</strong></span>, поэтому сделаем его абстрактным.</p>
<p>1. Создай абстрактный класс <span class="text-corporate"><strong>ZipCommand</strong></span>, реализующий интерфейс <strong><span class="text-yellow">Command</span></strong><br />
2. Создай по одному классу для каждой команды. Все перечисленные команды должны быть унаследованы от <strong><span class="text-corporate">ZipCommand</span></strong> и содержать пустую реализацию метода <mark>execute()</mark>, его реализацию мы будем писать для каждой команды отдельно по мере реализации нашего архиватора.<br />
2.1. Команда создания архива (<em>упаковки файлов в архив</em>) – <strong><span class="text-corporate">class ZipCreateCommand</span></strong><br />
2.2. Команда просмотра содержимого архива – <strong><span class="text-corporate">class ZipContentCommand</span></strong><br />
2.3. Команда распаковки архива – <span class="text-corporate"><strong>class ZipExtractCommand</strong></span><br />
2.4. Команда добавления файла в архив – <span class="text-corporate"><strong>class ZipAddCommand</strong></span><br />
2.5. Команда удаления файла из архива – <strong><span class="text-corporate">class ZipRemoveCommand</span></strong></p>

<hr>
<h3>Archiver (4)</h3>
<p>Каждая команда подразумевает выполнение каких-то действий. Создадим интерфейс <strong><span class="text-corporate">Command</span></strong>, с<br />
методом <mark>execute()</mark> (<strong>execute</strong> – «<em>выполнить» по-английски</em>). Для каждой команды мы создадим свой собственный класс. Все классы команд должны реализовывать (<em>быть унаследованы</em>) интерфейс <span class="text-corporate text-yellow"><strong>Command</strong></span>.<br />
Так как команд будет много, отведем для них отдельный пакет command. Все интерфейсы и реализации команд будем хранить именно в нем.<br />
Самая простая команда &#8212; это выход <mark class="green">EXIT</mark>, с нее и начнем.<br />
1. Создай пакет <strong><span class="text-red">command</span></strong><br />
2. В нем объявить интерфейс <strong><span class="text-yellow">Command</span></strong><br />
3. Добавь метод <mark>void execute() throws Exception</mark> в интерфейс <strong><span class="text-yellow">Command</span></strong><br />
4. Объяви класс <strong><span class="text-corporate">ExitCommand</span></strong>, реализующий интерфейс <strong><span class="text-yellow">Command</span></strong><br />
5. Реализуй метод <mark>execute()</mark> в классе <strong><span class="text-corporate">ExitCommand</span></strong>, он должен выводить “<em>До встречи!</em>” с помощью<br />
метода из класса <strong><span class="text-corporate">ConsoleHelper</span></strong><br />
6. В самом конце метода <mark>main</mark> в класса <strong><span class="text-corporate">Archiver</span></strong> добавь код, который создает объект типа <strong><span class="text-corporate">ExitCommand</span></strong> и вызывает у него метод <mark>execute()</mark><br />
7. Попробуй, как это все работает<br />
Обрати внимание, что все файлы проекта должны быть в кодировке <strong>UTF-8</strong>. Кодировку в <strong>IntelliJ IDEA</strong> можно задать через пункты меню <span class="text-neon">Settings -&gt; Editor -&gt; File Encodings</span>. Проверь, что все три поля отвечающие за кодировку выставлены в <strong>UTF-8</strong>.</p>

<hr>
<h3>Archiver (3)</h3>
<p>Как видишь, архивировать оказалось не так уж и сложно. Но наш архиватор получился каким-то уж<br />
слишком примитивным. Настоящий архиватор должен уметь гораздо больше: <strong><em>распаковку архива,</em></strong><br />
<strong><em> добавление нового файла в существующий архив, удаление файла из архива, просмотр содержимого</em></strong><br />
<strong><em> архива</em></strong>. Сейчас мы будем улучшать наш архиватор. А для этого придется написать несколько новых<br />
классов. Сначала давай создадим enum Operation, который будет содержать все команды, которые<br />
поддерживает наш архиватор.<br />
Так же было бы удобно использовать <strong><span class="text-corporate">ConsoleHelper</span></strong> для работы с консолью, чтобы все что касается<br />
консоли было собрано в одном классе. В дальнейшем, если не указано обратного, то весь ввод и вывод должен происходить через <strong><span class="text-corporate">ConsoleHelper</span></strong>.</p>
<p>1. Объяви <span class="text-corporate">enum</span><strong><span class="text-corporate"> Operation</span></strong>, в него добавить команды:<br />
1.1. Создать архив <mark class="green">CREATE</mark><br />
1.2. Добавить файл в архив <mark class="green">ADD</mark><br />
1.3. Удалить файл из архива <mark class="green">REMOVE</mark><br />
1.4. Извлечь содержимое архива <mark class="green">EXTRACT</mark><br />
1.5. Просмотреть содержимое архива <mark class="green">CONTENT</mark><br />
1.6. Выйти из программы <mark class="green">EXIT</mark><br />
2. Создай класс <strong><span class="text-corporate">ConsoleHelper</span></strong> и реализуй в нем статические публичные методы:<br />
2.1. Вывести сообщение в консоль <mark>void writeMessage(String <strong>message</strong>)</mark><br />
2.2. Прочитать строку с консоли <mark>String readString()</mark><br />
2.3. Прочитать число с консоли <mark>int readInt()</mark><br />
Методы чтения с консоли могут бросать исключение <strong><span class="text-yellow">IOException</span></strong> в случае ошибки ввода, учти<br />
это при их объявлении.</p>

</div>
