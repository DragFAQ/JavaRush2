<div class="wdghtml" taskKey="com.javarush.task.task31.task3110.big11">
<h3>Archiver (11)</h3>
<p>Давай наконец попробуем нормально реализовать метод <mark>execute()</mark> класса <span class="text-corporate"><strong>ZipCreateCommand</strong></span>, который мы добавляли раньше.</p>
<p><strong>Для этого нужно:</strong><br />
1. В начале метода добавить вывод сообщения &#171;<em>Создание архива.</em>&#187; Не забудь, что мы работаем с консолью через методы класса <span class="text-corporate"><strong>ConsoleHelper</strong></span>.<br />
2. Создай новый объект класса <span class="text-corporate"><strong>ZipFileManager</strong></span>. Т.к. создание этого объекта будет необходимо и другим командам, вынеси создание в отдельный метод <mark>ZipFileManager getZipFileManager() throws Exception</mark> в класс <span class="text-corporate"><strong>ZipCommand</strong></span>.<br />
<strong>Этот метод должен:</strong><br />
2.1. Просить пользователя ввести полный путь файла архива<br />
2.2. Считывать введенный путь в переменную типа <span class="text-corporate">String</span><br />
2.3. Используя введенный <span class="text-corporate">String</span> формировать путь <span class="text-corporate"><strong>Path</strong></span><br />
2.4. Создать объект <span class="text-corporate"><strong>ZipFileManager</strong></span>, передав в конструктор полученный путь<br />
2.5. Вернуть созданный объект<br />
3. Попроси пользователя ввести полное имя файла или директории для архивации<br />
4. Создай путь <span class="text-corporate"><strong>Path</strong></span>, используя введенную строку<br />
5. У объекта класса <span class="text-corporate"><strong>ZipFileManager</strong></span> вызови метод <mark>createZip()</mark>, передав в него путь из п.4<br />
6. Выведи в консоль сообщение &#171;<em>Архив создан.</em>&#187;<br />
7. Оберни содержимое метода <mark>execute()</mark> класса <span class="text-corporate"><strong>ZipCreateCommand</strong></span> в блок <span class="text-neon"><strong>try-catch</strong></span> и отлавливай<br />
исключение типа <strong><span class="text-corporate">PathIsNotFoundException</span></strong>. Если оно произошло, выведи сообщение &#171;<em>Вы неверно указали имя файла или директории.</em>&#187;<br />
8. Запусти программу и проверь, что команда &#171;<em>упаковать файлы в архив</em>&#187; работает</p>

<hr>
<h3>Archiver (10)</h3>
<p>Пришло время отрефакторить класс <strong><span class="text-corporate">ZipFileManager</span></strong>. В методе <mark>createZip</mark> есть код, который нам также понадобится в методах, которые будут добавлять или удалять файл в архив, распаковывать его и т.д. Эти методы мы будем реализовывать позже, но уже сейчас можем вынести общие части кода в отдельные методы.<br />
Кроме того, метод <mark>createZip</mark> мог создавать архив только из одного файла, а хотелось бы уметь<br />
архивировать всю папку целиком. Создавать отдельный метод для этого не будем, т.к. в <mark>createZip(<strong>Patsource</strong>)</mark> можно передавать и директорию и обычный файл.</p>
<p><strong>Задания на сегодня:</strong><br />
1. Реализуй приватный метод <mark>void addNewZipEntry(ZipOutputStream zipOutputStream, Path filePath, Path fileName) throws Exception</mark> в классе <strong><span class="text-corporate">ZipFileManager</span></strong>.<br />
<strong>Он должен:</strong><br />
1.1. Создавать <strong><span class="text-corporate">InputStream</span></strong>, для файла с именем <mark class="user">fileName</mark>, расположенным в<br />
директории <mark class="user">filePath</mark><br />
1.2. Создавать новый элемент архива <strong><span class="text-corporate">ZipEntry</span></strong>, в качестве имени используй <strong><span class="text-corporate">fileName</span>,</strong> преобразовав его в <span class="text-corporate">String</span><br />
1.3. Копировать данные из <strong><span class="text-corporate">InputStream</span></strong> (<em>из п.1.1</em>) в переданный <strong><span class="text-corporate">zipOutputStream</span></strong><br />
1.4. Закрывать элемент архива<br />
1.5. Закрывать <span class="text-corporate"><strong>InputStream</strong></span>, сделай это с помощью <strong><span class="text-neon">try-with-resources</span></strong><br />
2. Замени часть кода метода <mark>createZip</mark> вызовом нового метода <mark>addNewZipEntry</mark>. Передай значение <mark>source.getParent()</mark> в параметр <strong><span class="text-corporate">filePath</span></strong>, а <mark>source.getFileName()</mark> в <span class="text-corporate"><strong>filename</strong></span>.<br />
3. Реализуй приватный метод <mark>void copyData(InputStream in, OutputStream out) throws Exception</mark>. Он должен читать данные из <strong>in</strong> и записывать в <strong>out</strong>, пока не вычитает все.<br />
4. Замени часть кода метода <mark>addNewZipEntry</mark> на вызов метода <mark>copyData</mark><br />
5. Вернемся к <strong><span class="text-corporate">createZip</span></strong>:<br />
5.1. В начале метода проверь, что существует директория (<mark>zipFile.getParent()</mark>), в которой мы<br />
будем создавать <span class="text-corporate"><strong>zipFile</strong></span>, если ее нет, то создай ее.<br />
5.2. Если source является обычным файлом (<em>для проверки используй</em> <strong><span class="text-corporate">Files.isRegularFile</span></strong>), то оставим просто вызов <span class="text-corporate"><strong>addNewZipEntry</strong></span><br />
5.3. Если source является директорией (<em>для проверки используй</em> <span class="text-corporate"><strong>Files.isDirectory</strong></span>), то:<br />
5.3.1. Создай объект класса файловый менеджер <strong><span class="text-corporate">FileManager</span></strong>, в конструктор передадим <strong><span class="text-neon">source</span></strong><br />
5.3.2. Получи список файлов у файлового менеджера, сохраним его в переменную <span class="text-corporate"><strong>fileNames</strong></span><br />
5.3.3. Для всех элементов <span class="text-corporate"><strong>fileNames</strong></span>, вызови метод <mark>addNewZipEntry(zipOutputStream, source, fileName)</mark><br />
5.4. Если <span class="text-neon"><strong>source</strong></span> не является ни папкой, ни файлом, то кинь исключение <strong><span class="text-yellow">PathIsNotFoundException</span></strong>.</p>

<hr>
<h3>Archiver (9)</h3>
<p>Теперь займемся другой, не менее важной частью нашего архиватора. Очень часто пользователь хочет<br />
создать архив не из одного файла, а из целой папки. Тогда архивация сводится к поочередному<br />
добавлению элемента <strong><span class="text-corporate">ZipEntry</span></strong> для каждого файла в архив.<br />
Нам нужно написать класс <strong><span class="text-corporate">FileManager</span></strong> для получения списка всех файлов в какой-то папке. У него должен быть конструктор, который будет принимать путь <span class="text-corporate"><strong>Path</strong></span> <mark class="user">rootPath</mark>, указывающий на корень (<em>папку, файлы в которой нас интересуют</em>) и метод <mark>List&lt;Path&gt; getFileList()</mark>, который должен возвращать список относительных путей всех файлов, которые находятся по пути <mark class="user">rootPath</mark>, включая файлы в подпапках.<br />
Директория, в которой будем искать, может задаваться только один раз в конструкторе. Поэтому, прямо в конструкторе мы сразу можем сформировать список файлов (их относительных путей), сохранив его в переменную класса <span class="text-corporate">List</span><span class="text-corporate">&lt;Path&gt;</span><strong><span class="text-corporate"> fileList</span></strong>.<br />
Осталось только решить, как нам собрать все файлы, даже те, которые могут быть в папке, которая в папке, которая в папке, которая в интересующей нас папке. Фух, чуть не вошел рекурсию. Хотя нам-то она и поможет! Сделаем метод <mark>collectFileList(Path <strong>path</strong>)</mark>, который будет складывать в переменную класса fileList все файлы, обнаруженные внутри переданного пути path, вызывая сам себя для всех объектов, в обнаруженных директориях.</p>
<p>1. Создай класс <span class="text-corporate"><strong>FileManager</strong></span> с конструктором <mark>FileManager(Path <strong>rootPath</strong>) throws IOException</mark><br />
2. Объяви и проинициализируй приватные переменные класса:<br />
2.1. <span class="text-corporate">Path <mark class="user">rootPath</mark></span> – корневой путь директории, файлы которой нас интересуют<br />
2.2. <span class="text-red">List&lt;Path&gt; <strong>fileList</strong></span> – список относительных путей файлов внутри <mark class="user">rootPath</mark><br />
3. Создай <strong>геттер</strong> для <mark class="user">fileList</mark><br />
4. Реализуй метод <mark>void collectFileList(Path path) throws IOException</mark>, который должен:<br />
4.1. Проверить, если переданный путь path является обычным файлом (<em>используй метод </em><mark>Files.isRegularFile</mark>), то получить его относительный путь относительно rootPath и добавить его в список <mark class="user">fileList</mark>.<br />
4.2. Если переданный путь <mark class="user">path</mark>, является директорией (<em>узнать это поможет метод </em><mark>Files.isDirectory</mark>), то пройтись по всему содержимому директории и вызвать <mark>collectFileList(Path <strong>path</strong>)</mark>, передав в <mark class="user">path</mark> обнаруженные элементы.<br />
Пройтись по всему содержимому директории можно предварительно получив <mark>DirectoryStream</mark> с помощью метода <mark>newDirectoryStream</mark> класса <span class="text-corporate"><strong>Files</strong></span>. Не забудь закрыть созданный <strong><span class="text-corporate">DirectoryStream</span></strong>.<br />
5. Добавь вызов метода <mark>collectFileList(<strong>rootPath</strong>)</mark> в конструкторе <strong><span class="text-corporate">FileManager</span></strong>.<br />
6. Примени все свои знания об инкапсуляции к этому классу.<br />
Выполняя это задание, ты написал алгоритм, который обходит дерево файлов. Но в <strong>Java</strong> есть специальный интерфейс <strong><span class="text-yellow">FileVisitor</span></strong> для этих целей. Очень рекомендую разобраться как им пользоваться.</p>

<hr>
<h3>Archiver (8)</h3>
<p>Чтобы узнать какую команду сейчас хочет выполнить пользователь, добавим метод <mark>Operation</mark><br />
<mark> askOperation()</mark> в класс <strong><span class="text-corporate">Archiver</span></strong>. Этот метод должен вывести в консоль список доступных команд и<br />
попросить выбрать одну из них. Для удобства будем просить ввести номер команды, где номер – это<br />
порядковый номер команды в <span class="text-corporate">enum <strong>Operation</strong></span>. Получить порядковый номер значения в <span class="text-corporate">enum’е</span> можно с помощью метода <mark>ordinal()</mark>.<br />
Теперь все готово чтобы переписать main, используя последние достижения науки и техники, а именно<br />
класс <strong><span class="text-corporate">CommandExecutor</span></strong> и метод <mark>askOperation()</mark>.<br />
1. Добавь публичный статический метод <mark>Operation askOperation() throws IOException в класс Archiver</mark>.<br />
<strong>Он должен:</strong><br />
1.1. Использовать методы класса <span class="text-corporate"><strong>ConsoleHelper</strong></span><br />
1.2. Запрашивать у пользователя номер операции, которую он хочет совершить.</p>
<p><strong>Подсказка:</strong><br />
<em>чтобы вывести номер операции «Создать архив», используй: </em><mark>Operation.CREATE.ordinal()</mark></p>
<p>1.3. Возвращать выбранную операцию.</p>
<p><strong>Пример вывода метода askOperation():</strong><br />
<code>Выберите операцию:<br />
0 - упаковать файлы в архив<br />
1 - добавить файл в архив<br />
2 - удалить файл из архива<br />
3 - распаковать архив<br />
4 - просмотреть содержимое архива<br />
5 – выход</code><br />
2. Перепиши метод <mark>main()</mark>:<br />
2.1. Объяви локальную переменную типа <mark class="user">Operation</mark><br />
2.2. В цикле запрашивай новое значение для переменной <strong>п.2.1.</strong> с помощью метода <mark>askOperation()</mark> и вызывай выполнение операции с помощью <mark>CommandExecutor.execute()</mark><br />
2.3. Обеспечь выход из цикла, если пользователь выбрал операцию <mark>Operation.EXIT</mark><br />
2.4. Оберни вызов <mark>askOperation()</mark> и <mark>execute(operation)</mark> в блок <span class="text-neon"><strong>try-catch</strong></span>. Если произойдет исключение <strong><span class="text-yellow">WrongZipFileException</span></strong> выведи сообщение &#171;<em>Вы не выбрали файл архива или выбрали неверный файл.</em>&#187; с помощью <mark>ConsoleHelper</mark>, при любых других исключениях выводи &#171;<em>Произошла ошибка. Проверьте введенные данные.&#187;</em>.<br />
2.5. Проследи, чтобы программа продолжила свою работу (<em>перешла на новый шаг цикла</em>), после обработки исключений.<br />
3. Запусти программу и проверь, что команда “<em>выход</em>” работает.</p>

<hr>
<h3>Archiver (7)</h3>
<p>Мы много всего сделали и можно немного передохнуть.<br />
Создадим, пакет exception и добавим в него два класса <span class="text-corporate"><strong>PathIsNotFoundException</strong></span> и <strong><span class="text-corporate">WrongZipFileException</span></strong>.<br />
Исключение <strong><span class="text-yellow">PathIsNotFoundException</span></strong> будем кидать, если не сможем найти путь, в который нужно распаковать архив, или путь к файлу, который хотим запаковать, или любой другой путь. Исключение <strong><span class="text-yellow">WrongZipFileException</span></strong> будем кидать, если будет попытка сделать что-нибудь с архивом, который не<br />
существует.</p>
<p>1. Создай пакет <strong><span class="text-red">exception</span></strong><br />
2. Добавь в него класс <strong><span class="text-corporate">PathIsNotFoundException</span></strong> унаследованный от <strong><span class="text-corporate">Exception</span></strong><br />
3. Добавь класс <span class="text-corporate"><strong>WrongZipFileException</strong></span>, также унаследованный от <span class="text-corporate"><strong>Exception</strong></span></p>

<hr>
<h3>Archiver (6)</h3>
<p>Представь, что пользователь сообщает нам с помощью переменной <span class="text-corporate"><strong>Operation</strong></span> <mark class="user">operation</mark>, что он хочет сделать. Тогда мы должны проверить значение этой переменной, создать объект соответствующего класса команды и вызвать у него метод execute(). Чтобы не создавать объект класса нужной команды каждый раз, его нужно где-то хранить. Создадим для этих целей класс <strong><span class="text-corporate">CommandExecutor</span></strong>, пусть у него будет открытым только один публичный статический метод <mark>execute(Operation <strong>operation</strong>)</mark>, который найдет нужную команду и вызовет у нее метод execute.</p>
<p>1. Создай класс <strong><span class="text-corporate">CommandExecutor</span></strong>. Он должен быть в корне задачи, не стоит добавлять его в пакет <strong><span class="text-red">command</span></strong><br />
2. Запрети явный вызов конструктора этого класса<br />
3. Добавь в класс приватное статическое константное хранилище команд <span class="text-red">Map&lt;Operation, Command&gt;</span><br />
<strong><span class="text-red"> allKnownCommandsMap</span></strong><br />
4. Проинициализируй переменную <mark class="user">allKnownCommandsMap</mark> так, чтобы каждому значению из <span class="text-corporate"><strong>Operation</strong></span> соответствовала правильная команда.<br />
5. Реализуй публичный статический метод <mark>execute(Operation <strong>operation</strong>) throws Exception</mark>, который должен брать нужную команду из <span class="text-red">allKnownCommandsMap</span> и вызывать у нее метод <mark>execute</mark>.<br />
Догадался ты или нет, но ты только что реализовал паттерн Команда!</p>

</div>
