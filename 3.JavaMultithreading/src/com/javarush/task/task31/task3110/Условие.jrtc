<div class="wdghtml" taskKey="com.javarush.task.task31.task3110.big05">
<h3>Archiver (5)</h3>
<p><strong> Разделим команды на два типа</strong>: те, которые работают непосредственно с архивом и вспомогательные<br />
(например <mark class="green">EXIT</mark>). Все команды первого типа, будут иметь общий функционал, его удобно вынести в какой-то их общий базовый класс. Назовем этот класс <span class="text-corporate"><strong>ZipCommand</strong></span>. Он, как и все классы команд, должен реализовывать интерфейс <strong><span class="text-yellow">Command</span></strong>. Все команды, которые работают с архивом, должны быть унаследованы от класса <span class="text-corporate"><strong>ZipCommand</strong></span>. Мы не будем создавать объекты класса <span class="text-corporate"><strong>ZipCommand</strong></span>, поэтому сделаем его абстрактным.</p>
<p>1. Создай абстрактный класс <span class="text-corporate"><strong>ZipCommand</strong></span>, реализующий интерфейс <strong><span class="text-yellow">Command</span></strong><br />
2. Создай по одному классу для каждой команды. Все перечисленные команды должны быть унаследованы от <strong><span class="text-corporate">ZipCommand</span></strong> и содержать пустую реализацию метода <mark>execute()</mark>, его реализацию мы будем писать для каждой команды отдельно по мере реализации нашего архиватора.<br />
2.1. Команда создания архива (<em>упаковки файлов в архив</em>) – <strong><span class="text-corporate">class ZipCreateCommand</span></strong><br />
2.2. Команда просмотра содержимого архива – <strong><span class="text-corporate">class ZipContentCommand</span></strong><br />
2.3. Команда распаковки архива – <span class="text-corporate"><strong>class ZipExtractCommand</strong></span><br />
2.4. Команда добавления файла в архив – <span class="text-corporate"><strong>class ZipAddCommand</strong></span><br />
2.5. Команда удаления файла из архива – <strong><span class="text-corporate">class ZipRemoveCommand</span></strong></p>

<hr>
<h3>Archiver (4)</h3>
<p>Каждая команда подразумевает выполнение каких-то действий. Создадим интерфейс <strong><span class="text-corporate">Command</span></strong>, с<br />
методом <mark>execute()</mark> (<strong>execute</strong> – «<em>выполнить» по-английски</em>). Для каждой команды мы создадим свой собственный класс. Все классы команд должны реализовывать (<em>быть унаследованы</em>) интерфейс <span class="text-corporate text-yellow"><strong>Command</strong></span>.<br />
Так как команд будет много, отведем для них отдельный пакет command. Все интерфейсы и реализации команд будем хранить именно в нем.<br />
Самая простая команда &#8212; это выход <mark class="green">EXIT</mark>, с нее и начнем.<br />
1. Создай пакет <strong><span class="text-red">command</span></strong><br />
2. В нем объявить интерфейс <strong><span class="text-yellow">Command</span></strong><br />
3. Добавь метод <mark>void execute() throws Exception</mark> в интерфейс <strong><span class="text-yellow">Command</span></strong><br />
4. Объяви класс <strong><span class="text-corporate">ExitCommand</span></strong>, реализующий интерфейс <strong><span class="text-yellow">Command</span></strong><br />
5. Реализуй метод <mark>execute()</mark> в классе <strong><span class="text-corporate">ExitCommand</span></strong>, он должен выводить “<em>До встречи!</em>” с помощью<br />
метода из класса <strong><span class="text-corporate">ConsoleHelper</span></strong><br />
6. В самом конце метода <mark>main</mark> в класса <strong><span class="text-corporate">Archiver</span></strong> добавь код, который создает объект типа <strong><span class="text-corporate">ExitCommand</span></strong> и вызывает у него метод <mark>execute()</mark><br />
7. Попробуй, как это все работает<br />
Обрати внимание, что все файлы проекта должны быть в кодировке <strong>UTF-8</strong>. Кодировку в <strong>IntelliJ IDEA</strong> можно задать через пункты меню <span class="text-neon">Settings -&gt; Editor -&gt; File Encodings</span>. Проверь, что все три поля отвечающие за кодировку выставлены в <strong>UTF-8</strong>.</p>

<hr>
<h3>Archiver (3)</h3>
<p>Как видишь, архивировать оказалось не так уж и сложно. Но наш архиватор получился каким-то уж<br />
слишком примитивным. Настоящий архиватор должен уметь гораздо больше: <strong><em>распаковку архива,</em></strong><br />
<strong><em> добавление нового файла в существующий архив, удаление файла из архива, просмотр содержимого</em></strong><br />
<strong><em> архива</em></strong>. Сейчас мы будем улучшать наш архиватор. А для этого придется написать несколько новых<br />
классов. Сначала давай создадим enum Operation, который будет содержать все команды, которые<br />
поддерживает наш архиватор.<br />
Так же было бы удобно использовать <strong><span class="text-corporate">ConsoleHelper</span></strong> для работы с консолью, чтобы все что касается<br />
консоли было собрано в одном классе. В дальнейшем, если не указано обратного, то весь ввод и вывод должен происходить через <strong><span class="text-corporate">ConsoleHelper</span></strong>.</p>
<p>1. Объяви <span class="text-corporate">enum</span><strong><span class="text-corporate"> Operation</span></strong>, в него добавить команды:<br />
1.1. Создать архив <mark class="green">CREATE</mark><br />
1.2. Добавить файл в архив <mark class="green">ADD</mark><br />
1.3. Удалить файл из архива <mark class="green">REMOVE</mark><br />
1.4. Извлечь содержимое архива <mark class="green">EXTRACT</mark><br />
1.5. Просмотреть содержимое архива <mark class="green">CONTENT</mark><br />
1.6. Выйти из программы <mark class="green">EXIT</mark><br />
2. Создай класс <strong><span class="text-corporate">ConsoleHelper</span></strong> и реализуй в нем статические публичные методы:<br />
2.1. Вывести сообщение в консоль <mark>void writeMessage(String <strong>message</strong>)</mark><br />
2.2. Прочитать строку с консоли <mark>String readString()</mark><br />
2.3. Прочитать число с консоли <mark>int readInt()</mark><br />
Методы чтения с консоли могут бросать исключение <strong><span class="text-yellow">IOException</span></strong> в случае ошибки ввода, учти<br />
это при их объявлении.</p>

<hr>
<h3>Archiver (2)</h3>
<p>Сейчас мы напишем реализацию метода <mark>createZip(Path <strong>source</strong>)</mark>, в котором мы будем архивировать файл, заданный переменной source.<br />
В <strong>Java</strong> есть специальный класс <span class="text-corporate"><strong>ZipOutputStream</strong></span> из пакета <em><strong>java.util.zip</strong></em>, который сжимает (<em>архивирует</em>)<br />
переданные в него данные. Чтобы несколько файлов, сжимаемые в один архив, не слиплись вместе, для каждого из них создается специальная сущность – элемент архива <strong><span class="text-corporate">ZipEntry</span></strong>. Т.е. в <span class="text-corporate"><strong>ZipOutputStream</strong></span> мы сначала кладем <strong><span class="text-corporate">ZipEntry</span></strong>, а затем уже записываем содержимое файла. При записи файл автоматически сжимается, а при чтении – автоматически восстанавливается. <strong><span class="text-corporate">ZipEntry</span></strong> может быть не только файлом, но и папкой.</p>
<p><strong>Чтобы заархивировать файл (<em>создать новый архив и добавить в него файл</em>):</strong><br />
1. Создай новый поток архива <strong><span class="text-corporate">ZipOutputStream</span></strong> используя переменную класса <span class="text-corporate"><strong>zipFile</strong></span>, с помощью метода <mark>newOutputStream</mark> класса <strong><span class="text-corporate">Files</span></strong>.<br />
2. Создай новый элемент архива <strong><span class="text-corporate">ZipEntry</span></strong>. В конструктор <strong><span class="text-corporate">ZipEntry</span></strong> передай строку, содержащую имя новой записи. Имя нужно получить из полного пути source, взять только имя файла и сконвертировать его в <span class="text-corporate">String</span>.<br />
3. Добавь в поток архива созданный элемент архива.<br />
4. Перепиши данные из файла, который архивируем в поток архива. <strong>Для этого:</strong><br />
4.1. Создай поток <span class="text-corporate"><strong>InputStream</strong></span> для добавляемого файла <strong><span class="text-neon">source</span></strong>, используя метод <mark>newInputStream</mark> класса <strong><span class="text-corporate">Files</span></strong><br />
4.2. Сделай цикл, который будет читать данные из <strong><span class="text-corporate">InputStream</span></strong> (<em>созданного в п.4.1</em>), пока они там есть и записывать их в <strong><span class="text-corporate">ZipOutputStream</span></strong> (<em>созданный в п.1</em>)<br />
4.3. Закрой <strong><span class="text-corporate">InputStream</span></strong>, сделай это с помощью <strong><span class="text-neon">try-with-resource</span><span class="text-neon">s</span></strong><br />
5. Закрой элемент архива у потока архива<br />
6. Закрой поток архива, сделай это также с помощью <strong><span class="text-neon">try-with-resources</span></strong><br />
7. Запусти программу и проверь, что файл архивируется</p>

<hr>
<h3>Archiver (1)</h3>
<p>Давай напишем архиватор. <strong>Архиватор</strong>, как минимум, должен уметь архивировать и разархивировать<br />
файлы.</p>
<p><strong>Начнем с первого.</strong><br />
Нам потребуется менеджер архива. Он будет совершать операции над файлом архива (<em>файлом, который будет храниться на диске и иметь расширение <strong>zip</strong></em>). Класс, который будет этим заниматься, назовем <strong><span class="text-corporate">ZipFileManager</span></strong>. А главный класс приложения “<em><strong>Архиватор</strong></em>” будет называться <span class="text-corporate"><strong>Archiver</strong></span>.<br />
В программировании и не только, есть понятие полного (<em>абсолютного</em>) и относительного пути. Для начала, разберемся что-же такое путь вообще. Путь (<em>англ. Path</em>) – это набор символов, который показывает, где в операционной системе находится какой-то файл или папка.<br />
Полный или абсолютный путь – это путь, начинающийся с корневой директории. В операционной системе <em><strong>Windows</strong></em>, корневой директорией принято считать диск.<br />
Пример полного пути в Windows: <em>C:userzipsTest1.zip</em>.<br />
<strong>Относительный путь</strong> – это путь относительно какой-то директории. <em><strong>zipsTest1.zip</strong></em> &#8212; это пример<br />
относительного пути файла <em><strong>Test1.zip</strong></em> относительно директории (<em>папки</em>) <strong><em>C:user</em></strong>. Относительный путь,<br />
относительно директории <em><strong>C:userzips</strong></em> будет просто <em><strong>Test1.zip</strong></em> и совпадать с именем файла.<br />
Обрати внимание, что по умолчанию, и полный, и относительный путь к файлу, включают в себя имя<br />
файла.<br />
1. Создай класс менеджер <strong><span class="text-corporate">ZipFileManager</span></strong><br />
2. Добавь в класс приватную переменную <span class="text-corporate"><strong>Path</strong></span> <mark class="user">zipFile</mark>. В ней мы будем хранить полный путь к архиву, с которым будем работать.<br />
3. Добавь конструктор <mark>ZipFileManager(Path <strong>zipFile</strong>)</mark>. Проинициализируй поле класса <mark class="user">zipFile</mark>.<br />
4. Объяви публичный метод <mark>createZip(Path <strong>source</strong>) throws Exception</mark>, пока с пустой реализацией.<br />
<span class="text-corporate"><strong>Path</strong></span> <mark class="user">source</mark> – это путь к чему-то, что мы будем архивировать.<br />
5. Создай класс <strong><span class="text-corporate">Archiver</span></strong> и добавь в него метод <mark>main</mark>.<br />
6. В методе <mark>main</mark>:<br />
6.1 Запроси пользователя ввести полный путь архива с клавиатуры. Не забудь, что имя тоже входит в состав полного пути.<br />
6.2 Создай объект класса <strong><span class="text-corporate">ZipFileManager</span></strong>, передав в него имя файла архива. Разберись, как из <span class="text-corporate">String</span> получить <strong><span class="text-corporate">Path</span></strong>.</p>
<p><strong>Подсказка:</strong> <em>изучи метод </em><mark>get()</mark><em> класса </em><strong><span class="text-corporate">Paths</span></strong><em>.</em></p>
<p>6.3 Запроси пользователя ввести путь к файлу, который будем архивировать. Не путай это с файлом архива, который мы уже ввели. На этот раз нам нужен файл, который мы будем сжимать, а не в котором хранить сжатые данные.<br />
6.4 Вызови метод <mark>createZip</mark> у объекта <strong><span class="text-corporate">ZipFileManager</span></strong>, передав в него путь для архивации.</p>

</div>
