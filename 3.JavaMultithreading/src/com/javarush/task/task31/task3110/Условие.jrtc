<div class="wdghtml" taskKey="com.javarush.task.task31.task3110.big09">
<h3>Archiver (9)</h3>
<p>Теперь займемся другой, не менее важной частью нашего архиватора. Очень часто пользователь хочет<br />
создать архив не из одного файла, а из целой папки. Тогда архивация сводится к поочередному<br />
добавлению элемента <strong><span class="text-corporate">ZipEntry</span></strong> для каждого файла в архив.<br />
Нам нужно написать класс <strong><span class="text-corporate">FileManager</span></strong> для получения списка всех файлов в какой-то папке. У него должен быть конструктор, который будет принимать путь <span class="text-corporate"><strong>Path</strong></span> <mark class="user">rootPath</mark>, указывающий на корень (<em>папку, файлы в которой нас интересуют</em>) и метод <mark>List&lt;Path&gt; getFileList()</mark>, который должен возвращать список относительных путей всех файлов, которые находятся по пути <mark class="user">rootPath</mark>, включая файлы в подпапках.<br />
Директория, в которой будем искать, может задаваться только один раз в конструкторе. Поэтому, прямо в конструкторе мы сразу можем сформировать список файлов (их относительных путей), сохранив его в переменную класса <span class="text-corporate">List</span><span class="text-corporate">&lt;Path&gt;</span><strong><span class="text-corporate"> fileList</span></strong>.<br />
Осталось только решить, как нам собрать все файлы, даже те, которые могут быть в папке, которая в папке, которая в папке, которая в интересующей нас папке. Фух, чуть не вошел рекурсию. Хотя нам-то она и поможет! Сделаем метод <mark>collectFileList(Path <strong>path</strong>)</mark>, который будет складывать в переменную класса fileList все файлы, обнаруженные внутри переданного пути path, вызывая сам себя для всех объектов, в обнаруженных директориях.</p>
<p>1. Создай класс <span class="text-corporate"><strong>FileManager</strong></span> с конструктором <mark>FileManager(Path <strong>rootPath</strong>) throws IOException</mark><br />
2. Объяви и проинициализируй приватные переменные класса:<br />
2.1. <span class="text-corporate">Path <mark class="user">rootPath</mark></span> – корневой путь директории, файлы которой нас интересуют<br />
2.2. <span class="text-red">List&lt;Path&gt; <strong>fileList</strong></span> – список относительных путей файлов внутри <mark class="user">rootPath</mark><br />
3. Создай <strong>геттер</strong> для <mark class="user">fileList</mark><br />
4. Реализуй метод <mark>void collectFileList(Path path) throws IOException</mark>, который должен:<br />
4.1. Проверить, если переданный путь path является обычным файлом (<em>используй метод </em><mark>Files.isRegularFile</mark>), то получить его относительный путь относительно rootPath и добавить его в список <mark class="user">fileList</mark>.<br />
4.2. Если переданный путь <mark class="user">path</mark>, является директорией (<em>узнать это поможет метод </em><mark>Files.isDirectory</mark>), то пройтись по всему содержимому директории и вызвать <mark>collectFileList(Path <strong>path</strong>)</mark>, передав в <mark class="user">path</mark> обнаруженные элементы.<br />
Пройтись по всему содержимому директории можно предварительно получив <mark>DirectoryStream</mark> с помощью метода <mark>newDirectoryStream</mark> класса <span class="text-corporate"><strong>Files</strong></span>. Не забудь закрыть созданный <strong><span class="text-corporate">DirectoryStream</span></strong>.<br />
5. Добавь вызов метода <mark>collectFileList(<strong>rootPath</strong>)</mark> в конструкторе <strong><span class="text-corporate">FileManager</span></strong>.<br />
6. Примени все свои знания об инкапсуляции к этому классу.<br />
Выполняя это задание, ты написал алгоритм, который обходит дерево файлов. Но в <strong>Java</strong> есть специальный интерфейс <strong><span class="text-yellow">FileVisitor</span></strong> для этих целей. Очень рекомендую разобраться как им пользоваться.</p>

<hr>
<h3>Archiver (8)</h3>
<p>Чтобы узнать какую команду сейчас хочет выполнить пользователь, добавим метод <mark>Operation</mark><br />
<mark> askOperation()</mark> в класс <strong><span class="text-corporate">Archiver</span></strong>. Этот метод должен вывести в консоль список доступных команд и<br />
попросить выбрать одну из них. Для удобства будем просить ввести номер команды, где номер – это<br />
порядковый номер команды в <span class="text-corporate">enum <strong>Operation</strong></span>. Получить порядковый номер значения в <span class="text-corporate">enum’е</span> можно с помощью метода <mark>ordinal()</mark>.<br />
Теперь все готово чтобы переписать main, используя последние достижения науки и техники, а именно<br />
класс <strong><span class="text-corporate">CommandExecutor</span></strong> и метод <mark>askOperation()</mark>.<br />
1. Добавь публичный статический метод <mark>Operation askOperation() throws IOException в класс Archiver</mark>.<br />
<strong>Он должен:</strong><br />
1.1. Использовать методы класса <span class="text-corporate"><strong>ConsoleHelper</strong></span><br />
1.2. Запрашивать у пользователя номер операции, которую он хочет совершить.</p>
<p><strong>Подсказка:</strong><br />
<em>чтобы вывести номер операции «Создать архив», используй: </em><mark>Operation.CREATE.ordinal()</mark></p>
<p>1.3. Возвращать выбранную операцию.</p>
<p><strong>Пример вывода метода askOperation():</strong><br />
<code>Выберите операцию:<br />
0 - упаковать файлы в архив<br />
1 - добавить файл в архив<br />
2 - удалить файл из архива<br />
3 - распаковать архив<br />
4 - просмотреть содержимое архива<br />
5 – выход</code><br />
2. Перепиши метод <mark>main()</mark>:<br />
2.1. Объяви локальную переменную типа <mark class="user">Operation</mark><br />
2.2. В цикле запрашивай новое значение для переменной <strong>п.2.1.</strong> с помощью метода <mark>askOperation()</mark> и вызывай выполнение операции с помощью <mark>CommandExecutor.execute()</mark><br />
2.3. Обеспечь выход из цикла, если пользователь выбрал операцию <mark>Operation.EXIT</mark><br />
2.4. Оберни вызов <mark>askOperation()</mark> и <mark>execute(operation)</mark> в блок <span class="text-neon"><strong>try-catch</strong></span>. Если произойдет исключение <strong><span class="text-yellow">WrongZipFileException</span></strong> выведи сообщение &#171;<em>Вы не выбрали файл архива или выбрали неверный файл.</em>&#187; с помощью <mark>ConsoleHelper</mark>, при любых других исключениях выводи &#171;<em>Произошла ошибка. Проверьте введенные данные.&#187;</em>.<br />
2.5. Проследи, чтобы программа продолжила свою работу (<em>перешла на новый шаг цикла</em>), после обработки исключений.<br />
3. Запусти программу и проверь, что команда “<em>выход</em>” работает.</p>

<hr>
<h3>Archiver (7)</h3>
<p>Мы много всего сделали и можно немного передохнуть.<br />
Создадим, пакет exception и добавим в него два класса <span class="text-corporate"><strong>PathIsNotFoundException</strong></span> и <strong><span class="text-corporate">WrongZipFileException</span></strong>.<br />
Исключение <strong><span class="text-yellow">PathIsNotFoundException</span></strong> будем кидать, если не сможем найти путь, в который нужно распаковать архив, или путь к файлу, который хотим запаковать, или любой другой путь. Исключение <strong><span class="text-yellow">WrongZipFileException</span></strong> будем кидать, если будет попытка сделать что-нибудь с архивом, который не<br />
существует.</p>
<p>1. Создай пакет <strong><span class="text-red">exception</span></strong><br />
2. Добавь в него класс <strong><span class="text-corporate">PathIsNotFoundException</span></strong> унаследованный от <strong><span class="text-corporate">Exception</span></strong><br />
3. Добавь класс <span class="text-corporate"><strong>WrongZipFileException</strong></span>, также унаследованный от <span class="text-corporate"><strong>Exception</strong></span></p>

<hr>
<h3>Archiver (6)</h3>
<p>Представь, что пользователь сообщает нам с помощью переменной <span class="text-corporate"><strong>Operation</strong></span> <mark class="user">operation</mark>, что он хочет сделать. Тогда мы должны проверить значение этой переменной, создать объект соответствующего класса команды и вызвать у него метод execute(). Чтобы не создавать объект класса нужной команды каждый раз, его нужно где-то хранить. Создадим для этих целей класс <strong><span class="text-corporate">CommandExecutor</span></strong>, пусть у него будет открытым только один публичный статический метод <mark>execute(Operation <strong>operation</strong>)</mark>, который найдет нужную команду и вызовет у нее метод execute.</p>
<p>1. Создай класс <strong><span class="text-corporate">CommandExecutor</span></strong>. Он должен быть в корне задачи, не стоит добавлять его в пакет <strong><span class="text-red">command</span></strong><br />
2. Запрети явный вызов конструктора этого класса<br />
3. Добавь в класс приватное статическое константное хранилище команд <span class="text-red">Map&lt;Operation, Command&gt;</span><br />
<strong><span class="text-red"> allKnownCommandsMap</span></strong><br />
4. Проинициализируй переменную <mark class="user">allKnownCommandsMap</mark> так, чтобы каждому значению из <span class="text-corporate"><strong>Operation</strong></span> соответствовала правильная команда.<br />
5. Реализуй публичный статический метод <mark>execute(Operation <strong>operation</strong>) throws Exception</mark>, который должен брать нужную команду из <span class="text-red">allKnownCommandsMap</span> и вызывать у нее метод <mark>execute</mark>.<br />
Догадался ты или нет, но ты только что реализовал паттерн Команда!</p>

<hr>
<h3>Archiver (5)</h3>
<p><strong> Разделим команды на два типа</strong>: те, которые работают непосредственно с архивом и вспомогательные<br />
(например <mark class="green">EXIT</mark>). Все команды первого типа, будут иметь общий функционал, его удобно вынести в какой-то их общий базовый класс. Назовем этот класс <span class="text-corporate"><strong>ZipCommand</strong></span>. Он, как и все классы команд, должен реализовывать интерфейс <strong><span class="text-yellow">Command</span></strong>. Все команды, которые работают с архивом, должны быть унаследованы от класса <span class="text-corporate"><strong>ZipCommand</strong></span>. Мы не будем создавать объекты класса <span class="text-corporate"><strong>ZipCommand</strong></span>, поэтому сделаем его абстрактным.</p>
<p>1. Создай абстрактный класс <span class="text-corporate"><strong>ZipCommand</strong></span>, реализующий интерфейс <strong><span class="text-yellow">Command</span></strong><br />
2. Создай по одному классу для каждой команды. Все перечисленные команды должны быть унаследованы от <strong><span class="text-corporate">ZipCommand</span></strong> и содержать пустую реализацию метода <mark>execute()</mark>, его реализацию мы будем писать для каждой команды отдельно по мере реализации нашего архиватора.<br />
2.1. Команда создания архива (<em>упаковки файлов в архив</em>) – <strong><span class="text-corporate">class ZipCreateCommand</span></strong><br />
2.2. Команда просмотра содержимого архива – <strong><span class="text-corporate">class ZipContentCommand</span></strong><br />
2.3. Команда распаковки архива – <span class="text-corporate"><strong>class ZipExtractCommand</strong></span><br />
2.4. Команда добавления файла в архив – <span class="text-corporate"><strong>class ZipAddCommand</strong></span><br />
2.5. Команда удаления файла из архива – <strong><span class="text-corporate">class ZipRemoveCommand</span></strong></p>

<hr>
<h3>Archiver (4)</h3>
<p>Каждая команда подразумевает выполнение каких-то действий. Создадим интерфейс <strong><span class="text-corporate">Command</span></strong>, с<br />
методом <mark>execute()</mark> (<strong>execute</strong> – «<em>выполнить» по-английски</em>). Для каждой команды мы создадим свой собственный класс. Все классы команд должны реализовывать (<em>быть унаследованы</em>) интерфейс <span class="text-corporate text-yellow"><strong>Command</strong></span>.<br />
Так как команд будет много, отведем для них отдельный пакет command. Все интерфейсы и реализации команд будем хранить именно в нем.<br />
Самая простая команда &#8212; это выход <mark class="green">EXIT</mark>, с нее и начнем.<br />
1. Создай пакет <strong><span class="text-red">command</span></strong><br />
2. В нем объявить интерфейс <strong><span class="text-yellow">Command</span></strong><br />
3. Добавь метод <mark>void execute() throws Exception</mark> в интерфейс <strong><span class="text-yellow">Command</span></strong><br />
4. Объяви класс <strong><span class="text-corporate">ExitCommand</span></strong>, реализующий интерфейс <strong><span class="text-yellow">Command</span></strong><br />
5. Реализуй метод <mark>execute()</mark> в классе <strong><span class="text-corporate">ExitCommand</span></strong>, он должен выводить “<em>До встречи!</em>” с помощью<br />
метода из класса <strong><span class="text-corporate">ConsoleHelper</span></strong><br />
6. В самом конце метода <mark>main</mark> в класса <strong><span class="text-corporate">Archiver</span></strong> добавь код, который создает объект типа <strong><span class="text-corporate">ExitCommand</span></strong> и вызывает у него метод <mark>execute()</mark><br />
7. Попробуй, как это все работает<br />
Обрати внимание, что все файлы проекта должны быть в кодировке <strong>UTF-8</strong>. Кодировку в <strong>IntelliJ IDEA</strong> можно задать через пункты меню <span class="text-neon">Settings -&gt; Editor -&gt; File Encodings</span>. Проверь, что все три поля отвечающие за кодировку выставлены в <strong>UTF-8</strong>.</p>

</div>
